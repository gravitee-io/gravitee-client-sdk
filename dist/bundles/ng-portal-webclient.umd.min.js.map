{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://ng-portal-webclient/encoder.ts","ng://ng-portal-webclient/model/plan.ts","ng://ng-portal-webclient/variables.ts","ng://ng-portal-webclient/configuration.ts","ng://ng-portal-webclient/api/aPI.service.ts","ng://ng-portal-webclient/api/analytics.service.ts","ng://ng-portal-webclient/api/applications.service.ts","ng://ng-portal-webclient/api/authentication.service.ts","ng://ng-portal-webclient/api/documentation.service.ts","ng://ng-portal-webclient/api/portal.service.ts","ng://ng-portal-webclient/api/subscription.service.ts","ng://ng-portal-webclient/api/user.service.ts","ng://ng-portal-webclient/api/users.service.ts","ng://ng-portal-webclient/api/api.ts","ng://ng-portal-webclient/model/page.ts","ng://ng-portal-webclient/model/subscription.ts","ng://ng-portal-webclient/model/token.ts","ng://ng-portal-webclient/api.module.ts","ng://ng-portal-webclient/model/categoryApiQuery.ts","ng://ng-portal-webclient/model/httpMethod.ts","ng://ng-portal-webclient/model/identityProviderType.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","Plan","CustomHttpParameterCodec","prototype","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeURIComponent","decodeValue","BASE_PATH","InjectionToken","Configuration","configurationParameters","this","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","selectHeaderContentType","contentTypes","_this","type","find","x","isJsonMime","undefined","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","APIService","httpClient","configuration","defaultHeaders","HttpHeaders","createApiRatingForApi","apiId","RatingInput","observe","reportProgress","Error","headers","set","btoa","httpHeaderAcceptSelected","httpContentTypeSelected","post","String","getApiByApiId","include","queryParameters","HttpParams","forEach","element","append","get","params","getApiPlansByApiId","page","size","getApiRatingsByApiId","getApis","context_path","label","version","name","view","cat","getPageByApiIdAndPageId","pageId","getPagesByApiId","homepage","parent","getPictureByApiId","responseType","HttpClient","Optional","Inject","args","Injectable","providedIn","tslib_1.__param","AnalyticsService","exportApplicationLogsByApplicationId","applicationId","from","to","query","field","order","getApplicationAnalytics","interval","range","aggs","getApplicationLogByApplicationIdAndLogId","logId","timestamp","getApplicationLogs","ApplicationsService","createApplication","ApplicationInput","createApplicationMember","MemberInput","createApplicationNotification","GenericNotificationConfig","deleteApplicationByApplicationId","delete","deleteApplicationMember","memberId","deleteApplicationNotificationByNotificationId","notificationId","getApplicationByApplicationId","getApplicationMemberByApplicationIdAndMemberId","getApplicationPictureByApplicationId","getApplications","getMembersByApplicationId","getNotificationsByApplicationId","renewApplicationSecret","transferMemberOwnership","TransferOwnershipInput","updateApplicationByApplicationId","Application","put","updateApplicationMemberByApplicationIdAndMemberId","updateGenericApplicationNotification","updatePortalApplicationNotification","PortalNotificationConfig","AuthenticationService","exchangeAuthorizationCode","identity","PayloadInput","login","Authorization","logout","tokenExchange","token","DocumentationService","getPageByPageId","getPages","PortalService","createTicket","TicketInput","getPictureByViewId","viewId","getPortalConfiguration","getPortalIdentityProviders","getPortalInformation","getViewByViewId","getViews","SubscriptionService","closeSubscription","subscriptionId","createSubscription","SubscriptionInput","getSubscriptionBuySubscriptionId","getSubscriptions","renewKeySubscription","request_body","revokeKeySubscription","keyId","UserService","deleteAllCurrentUserNotifications","deleteCurrentUserNotificationByNotificationId","getCurrentUser","getCurrentUserAvatar","getCurrentUserNotifications","updateCurrentUser","User","UsersService","finalizeUserRegistration","FinalizeRegistrationInput","getUsers","registerNewUser","RegisterUserInput","APIS","Page","TypeEnum","SWAGGER","MARKDOWN","FOLDER","ROOT","SecurityEnum","APIKEY","KEYLESS","JWT","OAUTH2","ValidationEnum","AUTO","MANUAL","Subscription","StatusEnum","PENDING","ACCEPTED","REJECTED","Token","TokenTypeEnum","BEARER","ApiModule","parentModule","http","forRoot","configurationFactory","ngModule","ApiModule_1","providers","provide","useFactory","SkipSelf","NgModule","imports","declarations","exports","csv","tsv","ssv","pipes","FEATURED","MINE","STARRED","TRENDINGS","CONNECT","DELETE","GET","HEAD","OPTIONS","PATCH","POST","PUT","TRACE","OTHER","GOOGLE","GITHUB","GRAVITEEIOAM","OIDC"],"mappings":";;;;;;;;;;;;;;oFAoDO,SAASA,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HC,EAAvHC,EAAIC,UAAUC,OAAQC,EAAIH,EAAI,EAAIJ,EAAkB,OAATE,EAAgBA,EAAOM,OAAOC,yBAAyBT,EAAQC,GAAOC,EACrH,GAAuB,iBAAZQ,SAAoD,mBAArBA,QAAQC,SAAyBJ,EAAIG,QAAQC,SAASZ,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAIU,EAAIb,EAAWO,OAAS,EAAGM,GAAK,EAAGA,KAAST,EAAIJ,EAAWa,MAAIL,GAAKH,EAAI,EAAID,EAAEI,GAAKH,EAAI,EAAID,EAAEH,EAAQC,EAAKM,GAAKJ,EAAEH,EAAQC,KAASM,GAChJ,OAAOH,EAAI,GAAKG,GAAKC,OAAOK,eAAeb,EAAQC,EAAKM,GAAIA,EAGzD,SAASO,EAAQC,EAAYC,GAChC,OAAO,SAAUhB,EAAQC,GAAOe,EAAUhB,EAAQC,EAAKc,ICtD3D,ICiDiBE,EDjDjBC,EAAA,WAAA,SAAAA,KAaA,OAZIA,EAAAC,UAAAC,UAAA,SAAUC,GACN,OAAOC,mBAAmBD,IAE9BH,EAAAC,UAAAI,YAAA,SAAYC,GACR,OAAOF,mBAAmBE,IAE9BN,EAAAC,UAAAM,UAAA,SAAUJ,GACN,OAAOK,mBAAmBL,IAE9BH,EAAAC,UAAAQ,YAAA,SAAYH,GACR,OAAOE,mBAAmBF,IAElCN,EAbA,GEJaU,EAAY,IAAIC,EAAAA,eAAuB,yBCmBhD,SAAAC,EAAYC,QAAA,IAAAA,IAAAA,EAAA,IACRC,KAAKC,QAAUF,EAAwBE,QACvCD,KAAKE,SAAWH,EAAwBG,SACxCF,KAAKG,SAAWJ,EAAwBI,SACxCH,KAAKI,YAAcL,EAAwBK,YAC3CJ,KAAKK,SAAWN,EAAwBM,SACxCL,KAAKM,gBAAkBP,EAAwBO,gBAC/CN,KAAKO,QAAUR,EAAwBQ,QAuD/C,OA7CWT,EAAAX,UAAAqB,wBAAP,SAAgCC,GAAhC,IAAAC,EAAAV,KACI,GAA4B,IAAxBS,EAAanC,OAAjB,CAIA,IAAMqC,EAAOF,EAAaG,MAAK,SAACC,GAAc,OAAAH,EAAKI,WAAWD,MAC9D,YAAaE,IAATJ,EACOF,EAAa,GAEjBE,IAUJb,EAAAX,UAAA6B,mBAAP,SAA0BC,GAA1B,IAAAP,EAAAV,KACI,GAAuB,IAAnBiB,EAAQ3C,OAAZ,CAIA,IAAMqC,EAAOM,EAAQL,MAAK,SAACC,GAAc,OAAAH,EAAKI,WAAWD,MACzD,YAAaE,IAATJ,EACOM,EAAQ,GAEZN,IAaJb,EAAAX,UAAA2B,WAAP,SAAkBI,GACd,IAAMC,EAAmB,IAAIC,OAAO,8DAAiE,KACrG,OAAgB,OAATF,IAAkBC,EAASE,KAAKH,IAAgC,gCAAvBA,EAAKI,gBAE7DxB,kBCvCI,SAAAyB,EAAsBC,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAgB9CqC,EAAApC,UAAAyC,sBAAP,SAA6BC,EAAeC,EAA2BC,EAAuBC,GAC1F,QADmE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACtFH,MAAAA,EACA,MAAM,IAAII,MAAM,sFAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAgBvC,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,WACxGC,EACA,CACIxB,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrBT,EAAApC,UAAAsD,cAAP,SAAqBZ,EAAea,EAAoCX,EAAuBC,GAC3F,QADoE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACvFH,MAAAA,EACA,MAAM,IAAII,MAAM,8EAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChDmC,GACAA,EAAQG,SAAQ,SAACC,GACbH,EAAkBA,EAAgBI,OAAO,UAAgBD,MAIjE,IAAIZ,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAYhD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAC7F,CACIoB,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrBT,EAAApC,UAAA+D,mBAAP,SAA0BrB,EAAesB,EAAeC,EAAerB,EAAuBC,GAC1F,QADmE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACtFH,MAAAA,EACA,MAAM,IAAII,MAAM,mFAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAsBhD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,SAC9G,CACIoB,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrBT,EAAApC,UAAAkE,qBAAP,SAA4BxB,EAAesB,EAAeC,EAAerB,EAAuBC,GAC5F,QADqE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACxFH,MAAAA,EACA,MAAM,IAAII,MAAM,qFAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAwBhD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,WAChH,CACIoB,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAsBrBT,EAAApC,UAAAmE,QAAP,SAAeH,EAAeC,EAAeG,EAAuBC,EAAgBC,EAAkBC,EAAeC,EAAeC,EAAwB7B,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAE/K,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnDG,MAAAA,IACAZ,EAAkBA,EAAgBR,IAAI,eAAqBoB,IAE3DC,MAAAA,IACAb,EAAkBA,EAAgBR,IAAI,QAAcqB,IAEpDC,MAAAA,IACAd,EAAkBA,EAAgBR,IAAI,UAAgBsB,IAEtDC,MAAAA,IACAf,EAAkBA,EAAgBR,IAAI,OAAauB,IAEnDC,MAAAA,IACAhB,EAAkBA,EAAgBR,IAAI,OAAawB,IAEnDC,MAAAA,IACAjB,EAAkBA,EAAgBR,IAAI,MAAYyB,IAGtD,IAAI1B,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAqBhD,KAAKyB,cAAcpB,SAAQ,QACnE,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrBT,EAAApC,UAAA0E,wBAAP,SAA+BhC,EAAeiC,EAAgB/B,EAAuBC,GACjF,QAD0D,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC7EH,MAAAA,EACA,MAAM,IAAII,MAAM,wFAEpB,GAAI6B,MAAAA,EACA,MAAM,IAAI7B,MAAM,yFAGpB,IAAIC,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAahD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,UAAUvC,mBAAmBkD,OAAOsB,IACzI,CACIxD,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAmBrBT,EAAApC,UAAA4E,gBAAP,SAAuBlC,EAAesB,EAAeC,EAAeY,EAAoBC,EAAiBlC,EAAuBC,GAC5H,QADqG,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACxHH,MAAAA,EACA,MAAM,IAAII,MAAM,gFAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnDY,MAAAA,IACArB,EAAkBA,EAAgBR,IAAI,WAAiB6B,IAEvDC,MAAAA,IACAtB,EAAkBA,EAAgBR,IAAI,SAAe8B,IAGzD,IAAI/B,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAsBhD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,SAC9G,CACIoB,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerBT,EAAApC,UAAA+E,kBAAP,SAAyBrC,EAAeE,EAAuBC,GAC3D,QADoC,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACvDH,MAAAA,EACA,MAAM,IAAII,MAAM,kFAGpB,IAAIC,EAAUlC,KAAK0B,eAObW,EAA+CrC,KAAKyB,cAAcT,mBAJpC,CAChC,WACA,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAOhD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,WAC/F,CACIsC,aAAc,OACd7D,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CAzZMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtF9C,EAAUzD,EAAA,CAHtB0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtF9C,mBCCT,SAAAoD,EAAsBnD,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAsB9CyF,EAAAxF,UAAAyF,qCAAP,SAA4CC,EAAuB1B,EAAeC,EAAe0B,EAAeC,EAAaC,EAAgBC,EAAgBC,EAAwBnD,EAAuBC,GACxM,QADiL,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACpM6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,6GAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnD0B,MAAAA,IACAnC,EAAkBA,EAAgBR,IAAI,OAAa2C,IAEnDC,MAAAA,IACApC,EAAkBA,EAAgBR,IAAI,KAAW4C,IAEjDC,MAAAA,IACArC,EAAkBA,EAAgBR,IAAI,QAAc6C,IAEpDC,MAAAA,IACAtC,EAAkBA,EAAgBR,IAAI,QAAc8C,IAEpDC,MAAAA,IACAvC,EAAkBA,EAAgBR,IAAI,QAAc+C,IAGxD,IAAIhD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAIMkC,EAA+CrC,KAAKyB,cAAcT,mBAJpC,CAChC,aACA,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAgBvC,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,gBACxH,KACA,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KA0BrB2C,EAAAxF,UAAAgG,wBAAP,SAA+BN,EAAuB1B,EAAeC,EAAe0B,EAAeC,EAAaK,EAAmBJ,EAAgBC,EAAgBtE,EAA4C0E,EAAgBC,EAAeJ,EAAgBnD,EAAuBC,GACjR,QAD0P,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC7Q6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,gGAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnD0B,MAAAA,IACAnC,EAAkBA,EAAgBR,IAAI,OAAa2C,IAEnDC,MAAAA,IACApC,EAAkBA,EAAgBR,IAAI,KAAW4C,IAEjDK,MAAAA,IACAzC,EAAkBA,EAAgBR,IAAI,WAAiBiD,IAEvDJ,MAAAA,IACArC,EAAkBA,EAAgBR,IAAI,QAAc6C,IAEpDC,MAAAA,IACAtC,EAAkBA,EAAgBR,IAAI,QAAc8C,IAEpDtE,MAAAA,IACAgC,EAAkBA,EAAgBR,IAAI,OAAaxB,IAEnD0E,MAAAA,IACA1C,EAAkBA,EAAgBR,IAAI,QAAckD,IAEpDC,MAAAA,IACA3C,EAAkBA,EAAgBR,IAAI,OAAamD,IAEnDJ,MAAAA,IACAvC,EAAkBA,EAAgBR,IAAI,QAAc+C,IAGxD,IAAIhD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAA+DhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,aACvK,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrB2C,EAAAxF,UAAAoG,yCAAP,SAAgDV,EAAuBW,EAAeC,EAAoB1D,EAAuBC,GAC7H,QADsG,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACzH6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,iHAEpB,GAAIuD,MAAAA,EACA,MAAM,IAAIvD,MAAM,yGAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChDkF,MAAAA,IACA9C,EAAkBA,EAAgBR,IAAI,YAAkBsD,IAG5D,IAAIvD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAYhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,SAASvF,mBAAmBkD,OAAOgD,IACvJ,CACIvC,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAsBrB2C,EAAAxF,UAAAuG,mBAAP,SAA0Bb,EAAuB1B,EAAeC,EAAe0B,EAAeC,EAAaC,EAAgBC,EAAgBC,EAAwBnD,EAAuBC,GACtL,QAD+J,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAClL6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,2FAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnD0B,MAAAA,IACAnC,EAAkBA,EAAgBR,IAAI,OAAa2C,IAEnDC,MAAAA,IACApC,EAAkBA,EAAgBR,IAAI,KAAW4C,IAEjDC,MAAAA,IACArC,EAAkBA,EAAgBR,IAAI,QAAc6C,IAEpDC,MAAAA,IACAtC,EAAkBA,EAAgBR,IAAI,QAAc8C,IAEpDC,MAAAA,IACAvC,EAAkBA,EAAgBR,IAAI,QAAc+C,IAGxD,IAAIhD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAqBhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,QAC7H,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CA5SMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtFM,EAAgB7G,EAAA,CAH5B0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtFM,mBCiBT,SAAAgB,EAAsBnE,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAe9CyG,EAAAxG,UAAAyG,kBAAP,SAAyBC,EAAqC9D,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjF,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAqBvC,KAAKyB,cAAcpB,SAAQ,gBACnEwF,EACA,CACIvF,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAA2G,wBAAP,SAA+BjB,EAAuBkB,EAA2BhE,EAAuBC,GACpG,QAD6E,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAChG6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,gGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAgBvC,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,WACxHkB,EACA,CACIzF,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAA6G,8BAAP,SAAqCnB,EAAuBoB,EAAuDlE,EAAuBC,GACtI,QAD+G,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAClI6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,sGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAA8DvC,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,iBACtKoB,EACA,CACI3F,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerB2D,EAAAxG,UAAA+G,iCAAP,SAAwCrB,EAAuB9C,EAAuBC,GAClF,QAD2D,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC9E6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,yGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAW2E,OAAenG,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IACxG,CACIvE,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAAiH,wBAAP,SAA+BvB,EAAuBwB,EAAkBtE,EAAuBC,GAC3F,QADoE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACvF6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,gGAEpB,GAAIoE,MAAAA,EACA,MAAM,IAAIpE,MAAM,2FAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAW2E,OAAenG,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,YAAYvF,mBAAmBkD,OAAO6D,IAC7J,CACI/F,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAAmH,8CAAP,SAAqDzB,EAAuB0B,EAAwBxE,EAAuBC,GACvH,QADgG,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACnH6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,sHAEpB,GAAIsE,MAAAA,EACA,MAAM,IAAItE,MAAM,uHAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAW2E,OAAenG,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,kBAAkBvF,mBAAmBkD,OAAO+D,IACnK,CACIjG,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAsBrB2D,EAAAxG,UAAAyF,qCAAP,SAA4CC,EAAuB1B,EAAeC,EAAe0B,EAAeC,EAAaC,EAAgBC,EAAgBC,EAAwBnD,EAAuBC,GACxM,QADiL,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACpM6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,6GAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnD0B,MAAAA,IACAnC,EAAkBA,EAAgBR,IAAI,OAAa2C,IAEnDC,MAAAA,IACApC,EAAkBA,EAAgBR,IAAI,KAAW4C,IAEjDC,MAAAA,IACArC,EAAkBA,EAAgBR,IAAI,QAAc6C,IAEpDC,MAAAA,IACAtC,EAAkBA,EAAgBR,IAAI,QAAc8C,IAEpDC,MAAAA,IACAvC,EAAkBA,EAAgBR,IAAI,QAAc+C,IAGxD,IAAIhD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAIMkC,EAA+CrC,KAAKyB,cAAcT,mBAJpC,CAChC,aACA,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAgBvC,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,gBACxH,KACA,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KA0BrB2D,EAAAxG,UAAAgG,wBAAP,SAA+BN,EAAuB1B,EAAeC,EAAe0B,EAAeC,EAAaK,EAAmBJ,EAAgBC,EAAgBtE,EAA4C0E,EAAgBC,EAAeJ,EAAgBnD,EAAuBC,GACjR,QAD0P,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC7Q6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,gGAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnD0B,MAAAA,IACAnC,EAAkBA,EAAgBR,IAAI,OAAa2C,IAEnDC,MAAAA,IACApC,EAAkBA,EAAgBR,IAAI,KAAW4C,IAEjDK,MAAAA,IACAzC,EAAkBA,EAAgBR,IAAI,WAAiBiD,IAEvDJ,MAAAA,IACArC,EAAkBA,EAAgBR,IAAI,QAAc6C,IAEpDC,MAAAA,IACAtC,EAAkBA,EAAgBR,IAAI,QAAc8C,IAEpDtE,MAAAA,IACAgC,EAAkBA,EAAgBR,IAAI,OAAaxB,IAEnD0E,MAAAA,IACA1C,EAAkBA,EAAgBR,IAAI,QAAckD,IAEpDC,MAAAA,IACA3C,EAAkBA,EAAgBR,IAAI,OAAamD,IAEnDJ,MAAAA,IACAvC,EAAkBA,EAAgBR,IAAI,QAAc+C,IAGxD,IAAIhD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAA+DhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,aACvK,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerB2D,EAAAxG,UAAAqH,8BAAP,SAAqC3B,EAAuB9C,EAAuBC,GAC/E,QADwD,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC3E6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,sGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAoBhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAC7G,CACIvE,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrB2D,EAAAxG,UAAAoG,yCAAP,SAAgDV,EAAuBW,EAAeC,EAAoB1D,EAAuBC,GAC7H,QADsG,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACzH6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,iHAEpB,GAAIuD,MAAAA,EACA,MAAM,IAAIvD,MAAM,yGAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChDkF,MAAAA,IACA9C,EAAkBA,EAAgBR,IAAI,YAAkBsD,IAG5D,IAAIvD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAYhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,SAASvF,mBAAmBkD,OAAOgD,IACvJ,CACIvC,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAsBrB2D,EAAAxG,UAAAuG,mBAAP,SAA0Bb,EAAuB1B,EAAeC,EAAe0B,EAAeC,EAAaC,EAAgBC,EAAgBC,EAAwBnD,EAAuBC,GACtL,QAD+J,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAClL6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,2FAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnD0B,MAAAA,IACAnC,EAAkBA,EAAgBR,IAAI,OAAa2C,IAEnDC,MAAAA,IACApC,EAAkBA,EAAgBR,IAAI,KAAW4C,IAEjDC,MAAAA,IACArC,EAAkBA,EAAgBR,IAAI,QAAc6C,IAEpDC,MAAAA,IACAtC,EAAkBA,EAAgBR,IAAI,QAAc8C,IAEpDC,MAAAA,IACAvC,EAAkBA,EAAgBR,IAAI,QAAc+C,IAGxD,IAAIhD,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAqBhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,QAC7H,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAAsH,+CAAP,SAAsD5B,EAAuBwB,EAAkBtE,EAAuBC,GAClH,QAD2F,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC9G6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,uHAEpB,GAAIoE,MAAAA,EACA,MAAM,IAAIpE,MAAM,kHAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAehD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,YAAYvF,mBAAmBkD,OAAO6D,IAC7J,CACI/F,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerB2D,EAAAxG,UAAAuH,qCAAP,SAA4C7B,EAAuB9C,EAAuBC,GACtF,QAD+D,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAClF6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,6GAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAIMkC,EAA+CrC,KAAKyB,cAAcT,mBAJpC,CAChC,WACA,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAOhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,WAC/G,CACIV,aAAc,OACd7D,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAAwH,gBAAP,SAAuBxD,EAAeC,EAAerB,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAExE,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAA6BhD,KAAKyB,cAAcpB,SAAQ,gBAC3E,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrB2D,EAAAxG,UAAAyH,0BAAP,SAAiC/B,EAAuB1B,EAAeC,EAAerB,EAAuBC,GACzG,QADkF,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACrG6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,kGAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAwBhD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,WAChI,CACI5B,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerB2D,EAAAxG,UAAA0H,gCAAP,SAAuChC,EAAuB9C,EAAuBC,GACjF,QAD0D,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC7E6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,wGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAoChD,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,iBAC5I,CACIvE,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerB2D,EAAAxG,UAAA2H,uBAAP,SAA8BjC,EAAuB9C,EAAuBC,GACxE,QADiD,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACpE6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,+FAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAqBvC,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,iBAC7H,KACA,CACIvE,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAA4H,wBAAP,SAA+BlC,EAAuBmC,EAAiDjF,EAAuBC,GAC1H,QADmG,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACtH6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,gGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAavC,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,+BACrHmC,EACA,CACI1G,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAA8H,iCAAP,SAAwCpC,EAAuBqC,EAA2BnF,EAAuBC,GAC7G,QADsF,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACzG6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,yGAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAW2F,IAAoBnH,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAC7GqC,EACA,CACI5G,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrB2D,EAAAxG,UAAAiI,kDAAP,SAAyDvC,EAAuBwB,EAAkBN,EAA2BhE,EAAuBC,GAChJ,QADyH,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC5I6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,0HAEpB,GAAIoE,MAAAA,EACA,MAAM,IAAIpE,MAAM,qHAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAW2F,IAAenH,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,YAAYvF,mBAAmBkD,OAAO6D,IAC7JN,EACA,CACIzF,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrB2D,EAAAxG,UAAAkI,qCAAP,SAA4CxC,EAAuB0B,EAAwBN,EAAuDlE,EAAuBC,GACrK,QAD8I,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACjK6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,6GAEpB,GAAIsE,MAAAA,EACA,MAAM,IAAItE,MAAM,8GAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAW2F,IAAkCnH,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,kBAAkBvF,mBAAmBkD,OAAO+D,IACtLN,EACA,CACI3F,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB2D,EAAAxG,UAAAmI,oCAAP,SAA2CzC,EAAuB0C,EAAqDxF,EAAuBC,GAC1I,QADmH,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACtI6C,MAAAA,EACA,MAAM,IAAI5C,MAAM,4GAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAW2F,IAAiCnH,KAAKyB,cAAcpB,SAAQ,iBAAiBf,mBAAmBkD,OAAOqC,IAAe,iBACzI0C,EACA,CACIjH,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CA7pCMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtFsB,EAAmB7H,EAAA,CAH/B0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtFsB,mBCJT,SAAA6B,EAAsBhG,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAe9CsI,EAAArI,UAAAsI,0BAAP,SAAiCC,EAAkBC,EAA6B5F,EAAuBC,GACnG,QAD4E,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC/F0F,MAAAA,EACA,MAAM,IAAIzF,MAAM,6FAGpB,IAAIC,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAevC,KAAKyB,cAAcpB,SAAQ,gBAAgBf,mBAAmBkD,OAAOkF,IACvGC,EACA,CACIrH,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAcrBwF,EAAArI,UAAAyI,MAAP,SAAaC,EAAuB9F,EAAuBC,GACvD,QADgC,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACnD6F,MAAAA,EACA,MAAM,IAAI5F,MAAM,8EAGpB,IAAIC,EAAUlC,KAAK0B,eACfmG,MAAAA,IACA3F,EAAUA,EAAQC,IAAI,gBAAiBK,OAAOqF,MAI9C7H,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAevC,KAAKyB,cAAcpB,SAAQ,cAC7D,KACA,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAarBwF,EAAArI,UAAA2I,OAAP,SAAc/F,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjC,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAavC,KAAKyB,cAAcpB,SAAQ,eAC3D,KACA,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerBwF,EAAArI,UAAA4I,cAAP,SAAqBL,EAAkBM,EAAejG,EAAuBC,GACzE,QADkD,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACrE0F,MAAAA,EACA,MAAM,IAAIzF,MAAM,iFAEpB,GAAI+F,MAAAA,EACA,MAAM,IAAI/F,MAAM,8EAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChDyH,MAAAA,IACArF,EAAkBA,EAAgBR,IAAI,QAAc6F,IAGxD,IAAI9F,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAevC,KAAKyB,cAAcpB,SAAQ,gBAAgBf,mBAAmBkD,OAAOkF,IAAU,aACjH,KACA,CACIzE,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CA3LMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtFmD,EAAqB1J,EAAA,CAHjC0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtFmD,mBCOT,SAAAS,EAAsBzG,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAgB9C+I,EAAA9I,UAAA0E,wBAAP,SAA+BhC,EAAeiC,EAAgB/B,EAAuBC,GACjF,QAD0D,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC7EH,MAAAA,EACA,MAAM,IAAII,MAAM,wFAEpB,GAAI6B,MAAAA,EACA,MAAM,IAAI7B,MAAM,yFAGpB,IAAIC,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAahD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,UAAUvC,mBAAmBkD,OAAOsB,IACzI,CACIxD,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerBiG,EAAA9I,UAAA+I,gBAAP,SAAuBpE,EAAgB/B,EAAuBC,GAC1D,QADmC,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACtD8B,MAAAA,EACA,MAAM,IAAI7B,MAAM,iFAGpB,IAAIC,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAahD,KAAKyB,cAAcpB,SAAQ,UAAUf,mBAAmBkD,OAAOsB,IAC/F,CACIxD,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAkBrBiG,EAAA9I,UAAAgJ,SAAP,SAAgBhF,EAAeC,EAAeY,EAAoBC,EAAiBlC,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEtG,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnDY,MAAAA,IACArB,EAAkBA,EAAgBR,IAAI,WAAiB6B,IAEvDC,MAAAA,IACAtB,EAAkBA,EAAgBR,IAAI,SAAe8B,IAGzD,IAAI/B,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAsBhD,KAAKyB,cAAcpB,SAAQ,SACpE,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAmBrBiG,EAAA9I,UAAA4E,gBAAP,SAAuBlC,EAAesB,EAAeC,EAAeY,EAAoBC,EAAiBlC,EAAuBC,GAC5H,QADqG,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACxHH,MAAAA,EACA,MAAM,IAAII,MAAM,gFAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAEnDY,MAAAA,IACArB,EAAkBA,EAAgBR,IAAI,WAAiB6B,IAEvDC,MAAAA,IACAtB,EAAkBA,EAAgBR,IAAI,SAAe8B,IAGzD,IAAI/B,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAsBhD,KAAKyB,cAAcpB,SAAQ,SAASf,mBAAmBkD,OAAOX,IAAO,SAC9G,CACIoB,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CApMMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtF4D,EAAoBnK,EAAA,CAHhC0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtF4D,mBCWT,SAAAG,EAAsB5G,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAe9CkJ,EAAAjJ,UAAAkJ,aAAP,SAAoBC,EAA2BvG,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAElE,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAavC,KAAKyB,cAAcpB,SAAQ,WAC3DiI,EACA,CACIhI,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerBoG,EAAAjJ,UAAAoJ,mBAAP,SAA0BC,EAAgBzG,EAAuBC,GAC7D,QADsC,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACzDwG,MAAAA,EACA,MAAM,IAAIvG,MAAM,oFAGpB,IAAIC,EAAUlC,KAAK0B,eAObW,EAA+CrC,KAAKyB,cAAcT,mBAJpC,CAChC,WACA,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAOhD,KAAKyB,cAAcpB,SAAQ,UAAUf,mBAAmBkD,OAAOgG,IAAQ,WACjG,CACIrE,aAAc,OACd7D,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAcrBoG,EAAAjJ,UAAAsJ,uBAAP,SAA8B1G,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjD,IAAIE,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAA8BhD,KAAKyB,cAAcpB,SAAQ,iBAC5E,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAcrBoG,EAAAjJ,UAAAuJ,2BAAP,SAAkC3G,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAErD,IAAIE,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAwChD,KAAKyB,cAAcpB,SAAQ,4BACtF,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAcrBoG,EAAAjJ,UAAAwJ,qBAAP,SAA4B5G,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAE/C,IAAIE,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAahD,KAAKyB,cAAcpB,SAAQ,QAC3D,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerBoG,EAAAjJ,UAAAyJ,gBAAP,SAAuBJ,EAAgBzG,EAAuBC,GAC1D,QADmC,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACtDwG,MAAAA,EACA,MAAM,IAAIvG,MAAM,iFAGpB,IAAIC,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAahD,KAAKyB,cAAcpB,SAAQ,UAAUf,mBAAmBkD,OAAOgG,IAC/F,CACIlI,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrBoG,EAAAjJ,UAAA0J,SAAP,SAAgB1F,EAAeC,EAAerB,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjE,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,eAMbW,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAsBhD,KAAKyB,cAAcpB,SAAQ,SACpE,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CAtRMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtF+D,EAAatK,EAAA,CAHzB0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtF+D,mBCKT,SAAAU,EAAsBtH,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAe9C4J,EAAA3J,UAAA4J,kBAAP,SAAyBC,EAAwBjH,EAAuBC,GACpE,QAD6C,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAChEgH,MAAAA,EACA,MAAM,IAAI/G,MAAM,2FAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAavC,KAAKyB,cAAcpB,SAAQ,kBAAkBf,mBAAmBkD,OAAOwG,IAAgB,UACvH,KACA,CACI1I,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerB8G,EAAA3J,UAAA8J,mBAAP,SAA0BC,EAAuCnH,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEpF,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAsBvC,KAAKyB,cAAcpB,SAAQ,iBACpE6I,EACA,CACI5I,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB8G,EAAA3J,UAAAgK,iCAAP,SAAwCH,EAAwBtG,EAAyBX,EAAuBC,GAC5G,QADqF,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACxGgH,MAAAA,EACA,MAAM,IAAI/G,MAAM,0GAGpB,IAAIU,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChDmC,GACAA,EAAQG,SAAQ,SAACC,GACbH,EAAkBA,EAAgBI,OAAO,UAAgBD,MAIjE,IAAIZ,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAqBhD,KAAKyB,cAAcpB,SAAQ,kBAAkBf,mBAAmBkD,OAAOwG,IAC/G,CACI/F,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAiBrB8G,EAAA3J,UAAAiK,iBAAP,SAAwBvH,EAAgBgD,EAAwB1B,EAAeC,EAAerB,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjH,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChDsB,MAAAA,IACAc,EAAkBA,EAAgBR,IAAI,QAAcN,IAEpDgD,MAAAA,IACAlC,EAAkBA,EAAgBR,IAAI,gBAAsB0C,IAE5D1B,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAA8BhD,KAAKyB,cAAcpB,SAAQ,iBAC5E,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB8G,EAAA3J,UAAAkK,qBAAP,SAA4BL,EAAwBM,EAA8BvH,EAAuBC,GACrG,QAD8E,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACjGgH,MAAAA,EACA,MAAM,IAAI/G,MAAM,8FAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAavC,KAAKyB,cAAcpB,SAAQ,kBAAkBf,mBAAmBkD,OAAOwG,IAAgB,eACvHM,EACA,CACIhJ,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrB8G,EAAA3J,UAAAoK,sBAAP,SAA6BP,EAAwBQ,EAAezH,EAAuBC,GACvF,QADgE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GACnFgH,MAAAA,EACA,MAAM,IAAI/G,MAAM,+FAEpB,GAAIuH,MAAAA,EACA,MAAM,IAAIvH,MAAM,sFAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWe,KAAavC,KAAKyB,cAAcpB,SAAQ,kBAAkBf,mBAAmBkD,OAAOwG,IAAgB,SAAS1J,mBAAmBkD,OAAOgH,IAAO,WACjK,KACA,CACIlJ,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CArTMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtFyE,EAAmBhL,EAAA,CAH/B0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtFyE,mBCKT,SAAAW,EAAsBjI,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAc9CuK,EAAAtK,UAAAuK,kCAAP,SAAyC3H,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAE5D,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAW2E,OAAenG,KAAKyB,cAAcpB,SAAQ,sBAC7D,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerByH,EAAAtK,UAAAwK,8CAAP,SAAqDpD,EAAwBxE,EAAuBC,GAChG,QADyE,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAC5FuE,MAAAA,EACA,MAAM,IAAItE,MAAM,uHAGpB,IAAIC,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAW2E,OAAenG,KAAKyB,cAAcpB,SAAQ,uBAAuBf,mBAAmBkD,OAAO+D,IAC9G,CACIjG,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAcrByH,EAAAtK,UAAAyK,eAAP,SAAsB7H,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEzC,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAahD,KAAKyB,cAAcpB,SAAQ,QAC3D,CACIC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAcrByH,EAAAtK,UAAA0K,qBAAP,SAA4B9H,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAE/C,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAIMkC,EAA+CrC,KAAKyB,cAAcT,mBAJpC,CAChC,WACA,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAOhD,KAAKyB,cAAcpB,SAAQ,eACrD,CACI8D,aAAc,OACd7D,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrByH,EAAAtK,UAAA2K,4BAAP,SAAmC3G,EAAeC,EAAerB,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEpF,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAoChD,KAAKyB,cAAcpB,SAAQ,sBAClF,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerByH,EAAAtK,UAAA4K,kBAAP,SAAyBC,EAAajI,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEzD,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAW2F,IAAanH,KAAKyB,cAAcpB,SAAQ,QAC3D2J,EACA,CACI1J,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CA1QMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtFoF,EAAW3L,EAAA,CAHvB0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtFoF,mBCST,SAAAQ,EAAsBzI,EAAsDnB,EAA8BoB,GAApFzB,KAAAwB,WAAAA,EALZxB,KAAAK,SAAW,yCACdL,KAAA0B,eAAiB,IAAIC,EAAAA,YACrB3B,KAAAyB,cAAgB,IAAI3B,EAInB2B,IACAzB,KAAKyB,cAAgBA,GAEkB,iBAAhCzB,KAAKyB,cAAcpB,WACF,iBAAbA,IACPA,EAAWL,KAAKK,UAEpBL,KAAKyB,cAAcpB,SAAWA,GAElCL,KAAKO,QAAUP,KAAKyB,cAAclB,SAAW,IAAIrB,SAe9C+K,EAAA9K,UAAA+K,yBAAP,SAAgCC,EAAuDpI,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAE1G,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAcvC,KAAKyB,cAAcpB,SAAQ,gCAC5D8J,EACA,CACI7J,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAgBrBiI,EAAA9K,UAAAiL,SAAP,SAAgBjH,EAAeC,EAAerB,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjE,IAAIW,EAAkB,IAAIC,EAAAA,WAAW,CAACrC,QAASP,KAAKO,UAChD4C,MAAAA,IACAR,EAAkBA,EAAgBR,IAAI,OAAagB,IAEnDC,MAAAA,IACAT,EAAkBA,EAAgBR,IAAI,OAAaiB,IAGvD,IAAIlB,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,qBAQJ,YALiCD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAI7BrC,KAAKwB,WAAWwB,IAAsBhD,KAAKyB,cAAcpB,SAAQ,SACpE,CACI4C,OAAQN,EACRrC,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,KAerBiI,EAAA9K,UAAAkL,gBAAP,SAAuBC,EAAuCvI,EAAuBC,QAAvB,IAAAD,IAAAA,EAAA,aAAuB,IAAAC,IAAAA,GAAA,GAEjF,IAAIE,EAAUlC,KAAK0B,gBAGf1B,KAAKyB,cAAcvB,UAAYF,KAAKyB,cAActB,YAClD+B,EAAUA,EAAQC,IAAI,gBAAiB,SAAWC,KAAKpC,KAAKyB,cAAcvB,SAAW,IAAMF,KAAKyB,cAActB,YAIlH,IAGMkC,EAA+CrC,KAAKyB,cAAcT,mBAHpC,CAChC,0BAG6BD,IAA7BsB,IACAH,EAAUA,EAAQC,IAAI,SAAUE,IAKpC,IAGMC,EAA8CtC,KAAKyB,cAAcjB,wBAH5C,CACvB,qBAOJ,YAJgCO,IAA5BuB,IACAJ,EAAUA,EAAQC,IAAI,eAAgBG,IAGnCtC,KAAKwB,WAAWe,KAAcvC,KAAKyB,cAAcpB,SAAQ,sBAC5DiK,EACA,CACIhK,gBAAiBN,KAAKyB,cAAcnB,gBACpC4B,QAASA,EACTH,QAASA,EACTC,eAAgBA,8CA7JMoC,EAAAA,2CAAaC,EAAAA,UAAQ,CAAA1D,KAAG2D,EAAAA,OAAMC,KAAA,CAAC3E,YAAwDE,EAAa/B,WAAA,CAAA,CAAA4C,KAAvC0D,EAAAA,6KAPtF4F,EAAYnM,EAAA,CAHxB0G,EAAAA,WAAW,CACVC,WAAY,SASqCC,EAAAA,EAAAL,EAAAA,YAAWK,EAAAA,EAAAJ,EAAAA,OAAO1E,IAA8B8E,EAAAA,EAAAL,EAAAA,aAPtF4F,MCdAM,EAAO,CAAChJ,EAAYoD,EAAkBgB,EAAqB6B,EAAuBS,EAAsBG,EAAeU,EAAqBW,EAAaQ,ICmCrJO,EAAAA,OAAAA,EAAAA,KAAI,KAEJC,SAAW,CACpBC,QAAS,UACTC,SAAU,WACVC,OAAQ,SACRC,KAAM,SbJG5L,EAAAA,EAAAA,OAAAA,EAAAA,KAAI,KAEJ6L,aAAe,CACxBC,OAAQ,UACRC,QAAS,WACTC,IAAK,MACLC,OAAQ,UAGCjM,EAAAkM,eAAiB,CAC1BC,KAAM,OACNC,OAAQ,WcNCC,EAAAA,eAAAA,EAAAA,aAAY,KAEZC,WAAa,CACtBC,QAAS,UACTC,SAAU,WACVC,SAAU,aChDDC,EAAAA,QAAAA,EAAAA,MAAK,KAELC,cAAgB,CACzBC,OAAQ,2BCkBZ,SAAAC,EAAqCC,EACZC,GACrB,GAAID,EACA,MAAM,IAAI9J,MAAM,oEAEpB,IAAK+J,EACD,MAAM,IAAI/J,MAAM,+HAI5B,SAlBa6J,EACKA,EAAAG,QAAd,SAAsBC,GAClB,MAAO,CACHC,SAAUC,EACVC,UAAW,CAAE,CAAEC,QAASxM,EAAeyM,WAAYL,+CAIRJ,EAAS/N,WAAA,CAAA,CAAA4C,KAA9C0D,EAAAA,UAAQ,CAAA1D,KAAI6L,EAAAA,kBACKpI,EAAAA,WAAUrG,WAAA,CAAA,CAAA4C,KAA3B0D,EAAAA,cATLyH,EAASM,EAAAtO,EAAA,CAfrB2O,EAAAA,SAAS,CACRC,QAAc,GACdC,aAAc,GACdC,QAAc,GACdP,UAAW,CACT9K,EACAoD,EACAgB,EACA6B,EACAS,EACAG,EACAU,EACAW,EACAQ,KAUcvF,EAAAA,EAAAL,EAAAA,YAAYK,EAAAA,EAAA8H,EAAAA,YACZ9H,EAAAA,EAAAL,EAAAA,aATLyH,sJf3BqB,CAC9Be,IAAO,IACPC,IAAO,MACPC,IAAO,IACPC,MAAS,wBgBQmB,CAC5BC,SAAU,WACVC,KAAM,OACNC,QAAS,UACTC,UAAW,qECJW,CACtBC,QAAS,UACTC,OAAQ,SACRC,IAAK,MACLC,KAAM,OACNC,QAAS,UACTC,MAAO,QACPC,KAAM,OACNC,IAAK,MACLC,MAAO,QACPC,MAAO,gCCPyB,CAChCC,OAAQ,SACRC,OAAQ,SACRC,aAAc,gBACdC,KAAM","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface Plan { \n    /**\n     * Unique identifier of a plan.\n     */\n    id: string;\n    /**\n     * Name of the plan.\n     */\n    name: string;\n    /**\n     * Security used with this plan.\n     */\n    security: Plan.SecurityEnum;\n    /**\n     * Description of the plan.\n     */\n    description: string;\n    /**\n     * List of additionnal terms to describe the plan.\n     */\n    characteristics?: Array<string>;\n    /**\n     * Type of validation for subscription requests.\n     */\n    validation: Plan.ValidationEnum;\n    /**\n     * Priority order\n     */\n    order: number;\n    /**\n     * True if at least one application linked to the current user has subscribed to this plan.\n     */\n    subscribed?: boolean;\n    /**\n     * True if a comment is required when a subscription is created.\n     */\n    comment_required: boolean;\n    /**\n     * Content of the message sent to a user creating a subscription.\n     */\n    comment_question?: string;\n}\nexport namespace Plan {\n    export type SecurityEnum = 'API_KEY' | 'KEY_LESS' | 'JWT' | 'OAUTH2';\n    export const SecurityEnum = {\n        APIKEY: 'API_KEY' as SecurityEnum,\n        KEYLESS: 'KEY_LESS' as SecurityEnum,\n        JWT: 'JWT' as SecurityEnum,\n        OAUTH2: 'OAUTH2' as SecurityEnum\n    };\n    export type ValidationEnum = 'AUTO' | 'MANUAL';\n    export const ValidationEnum = {\n        AUTO: 'AUTO' as ValidationEnum,\n        MANUAL: 'MANUAL' as ValidationEnum\n    };\n}\n\n\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n}\n\nexport class Configuration {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { Api } from '../model/api';\nimport { ApisResponse } from '../model/apisResponse';\nimport { CategoryApiQuery } from '../model/categoryApiQuery';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Page } from '../model/page';\nimport { PagesResponse } from '../model/pagesResponse';\nimport { PlansResponse } from '../model/plansResponse';\nimport { Rating } from '../model/rating';\nimport { RatingInput } from '../model/ratingInput';\nimport { RatingsResponse } from '../model/ratingsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class APIService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Create a rating for an API\n     * Create a rating for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned.  The current must have API_RATING[CREATE] permission to create a rating. \n     * @param apiId Id of an API.\n     * @param RatingInput Use to add a rating to an api\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApiRatingForApi(apiId: string, RatingInput?: RatingInput, observe?: 'body', reportProgress?: boolean): Observable<Rating>;\n    public createApiRatingForApi(apiId: string, RatingInput?: RatingInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Rating>>;\n    public createApiRatingForApi(apiId: string, RatingInput?: RatingInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Rating>>;\n    public createApiRatingForApi(apiId: string, RatingInput?: RatingInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling createApiRatingForApi.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Rating>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings`,\n            RatingInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the API definition\n     * Get the detail of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param include Comma-separated list of related objects to include in the response.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApiByApiId(apiId: string, include?: Array<'pages' | 'plans'>, observe?: 'body', reportProgress?: boolean): Observable<Api>;\n    public getApiByApiId(apiId: string, include?: Array<'pages' | 'plans'>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Api>>;\n    public getApiByApiId(apiId: string, include?: Array<'pages' | 'plans'>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Api>>;\n    public getApiByApiId(apiId: string, include?: Array<'pages' | 'plans'>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getApiByApiId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (include) {\n            include.forEach((element) => {\n                queryParameters = queryParameters.append('include', <any>element);\n            })\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Api>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List plans for an API\n     * List plans for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApiPlansByApiId(apiId: string, page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<PlansResponse>;\n    public getApiPlansByApiId(apiId: string, page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlansResponse>>;\n    public getApiPlansByApiId(apiId: string, page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlansResponse>>;\n    public getApiPlansByApiId(apiId: string, page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getApiPlansByApiId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PlansResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/plans`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List ratings for an API\n     * List ratings for an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApiRatingsByApiId(apiId: string, page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<RatingsResponse>;\n    public getApiRatingsByApiId(apiId: string, page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RatingsResponse>>;\n    public getApiRatingsByApiId(apiId: string, page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RatingsResponse>>;\n    public getApiRatingsByApiId(apiId: string, page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getApiRatingsByApiId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<RatingsResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/ratings`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List APIs\n     * List public APIs for anonymous requests. List all the APIs the current user is allowed to view for authenticated requests.  The list can be filtered according to query parameters.  By default the list is sorted by alphabetic order. If a **cat** query param is sent, a specific sorting can be applied. Please refer to **cat** description for detail. \n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param context_path The context-path of an API.\n     * @param label One of the labels of an API.\n     * @param version The version of an API.\n     * @param name The name of an API.\n     * @param view One of the view linked with an API.\n     * @param cat Name of a CATEGORY. A category is a static filter used to pre-select some APIs. It can be combined with others query params.   - FEATURED : top APIs. Sorted by alphabetical order.   - MINE : APIs subscribed by the current user. Sorted by alphabetical order.   - STARRED: Rated APIs. Sorted by Ratings DESC, nb of ratings DESC, alphabetic order.   - TRENDINGS: Subscribed APIs. Sorted by number of subscriptions DESC, alphabetic order. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApis(page?: number, size?: number, context_path?: string, label?: string, version?: string, name?: string, view?: string, cat?: CategoryApiQuery, observe?: 'body', reportProgress?: boolean): Observable<ApisResponse>;\n    public getApis(page?: number, size?: number, context_path?: string, label?: string, version?: string, name?: string, view?: string, cat?: CategoryApiQuery, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApisResponse>>;\n    public getApis(page?: number, size?: number, context_path?: string, label?: string, version?: string, name?: string, view?: string, cat?: CategoryApiQuery, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApisResponse>>;\n    public getApis(page?: number, size?: number, context_path?: string, label?: string, version?: string, name?: string, view?: string, cat?: CategoryApiQuery, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (context_path !== undefined && context_path !== null) {\n            queryParameters = queryParameters.set('context-path', <any>context_path);\n        }\n        if (label !== undefined && label !== null) {\n            queryParameters = queryParameters.set('label', <any>label);\n        }\n        if (version !== undefined && version !== null) {\n            queryParameters = queryParameters.set('version', <any>version);\n        }\n        if (name !== undefined && name !== null) {\n            queryParameters = queryParameters.set('name', <any>name);\n        }\n        if (view !== undefined && view !== null) {\n            queryParameters = queryParameters.set('view', <any>view);\n        }\n        if (cat !== undefined && cat !== null) {\n            queryParameters = queryParameters.set('cat', <any>cat);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ApisResponse>(`${this.configuration.basePath}/apis`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an API page\n     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param pageId Id of a documentation page.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe?: 'body', reportProgress?: boolean): Observable<Page>;\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n        if (pageId === null || pageId === undefined) {\n            throw new Error('Required parameter pageId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Page>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages/${encodeURIComponent(String(pageId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List API pages\n     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param homepage If true, only the documentation homepage of the portal is returned.\n     * @param parent The name of the parent documentation page. If not null, only this page and its children are returned.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPagesByApiId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (homepage !== undefined && homepage !== null) {\n            queryParameters = queryParameters.set('homepage', <any>homepage);\n        }\n        if (parent !== undefined && parent !== null) {\n            queryParameters = queryParameters.set('parent', <any>parent);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the API\\&#39;s picture\n     * Get the API\\&#39;s picture.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPictureByApiId(apiId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getPictureByApiId(apiId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getPictureByApiId(apiId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getPictureByApiId(apiId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPictureByApiId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/picture`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DateHistoAnalytics, GroupByAnalytics, CountAnalytics } from '../model/models';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Log } from '../model/log';\nimport { LogsResponse } from '../model/logsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnalyticsService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Export application logs as CSV\n     * Export application logs as CSV.  User must have the APPLICATION_LOG[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param from Lower bound of timestamp for filtering.\n     * @param to Upper bound of timestamp for filtering. Must be greater than *from* query param.\n     * @param query Query used for filtering.\n     * @param field Field used for filtering. **required** when type is **GROUP_BY**.\n     * @param order Order used to sort the result list.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean): Observable<string>;\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationLogsByApplicationId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'text/plain',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<string>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/_export`,\n            null,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application analytics\n     * Get the application analytics.  User must have the APPLICATION_ANALYTICS[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param from Lower bound of timestamp for filtering.\n     * @param to Upper bound of timestamp for filtering. Must be greater than *from* query param.\n     * @param interval Interval for time search. Must be &gt;&#x3D; 1 000 and &lt;&#x3D; 1 000 000 000.\n     * @param query Query used for filtering.\n     * @param field Field used for filtering. **required** when type is **GROUP_BY**.\n     * @param type Type of analytics that is expected :   - GROUP_BY :       Used to group total hits by a specific field (Application, Status, Path, ...).\\\\       Query params :       - from       - to       - interval       - query       - field       - order       - ranges   - DATE_HISTO :        Used to retrieve total hits per range of time, on a specific time interval.\\\\       Query params :       - from       - to       - interval       - query       - aggs   - COUNT :        Used to retrieve total hits, on a specific time interval.\\\\       Query params :       - from       - to       - interval       - query \n     * @param range Used with GROUP_BY type only.  A semicolon separated list of \\&quot;from:to\\&quot; elements. **_/!\\\\\\\\ Different from *from* and *to* query params** \n     * @param aggs Used with DATE_HISTO type only.  A semicolon separated list of \\&quot;type:field\\&quot; elements. **_/!\\\\\\\\ Different from *type* and *field* query params**\\\\ Type can be **FIELD**, **AVG**, **MIN**, **MAX** \n     * @param order Used with GROUP_BY type only.   A colon separated list of \\&quot;type:field\\&quot; elements. **_/!\\\\\\\\ Different from *type* and *field* query params**\\\\ By default, sort is ASC. If *type* starts with \\&#39;-\\&#39;, the order sort is DESC.\\\\ Currently, only **AVG** is supported. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe?: 'body', reportProgress?: boolean): Observable<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>;\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationAnalytics.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (interval !== undefined && interval !== null) {\n            queryParameters = queryParameters.set('interval', <any>interval);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (type !== undefined && type !== null) {\n            queryParameters = queryParameters.set('type', <any>type);\n        }\n        if (range !== undefined && range !== null) {\n            queryParameters = queryParameters.set('range', <any>range);\n        }\n        if (aggs !== undefined && aggs !== null) {\n            queryParameters = queryParameters.set('aggs', <any>aggs);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/analytics`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a specific log of an application\n     * Get a specific log of an application.  User must have the APPLICATION_LOG[READ] permission. \n     * @param applicationId Id of an application.\n     * @param logId Id of a log.\n     * @param timestamp Used to select the right index\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe?: 'body', reportProgress?: boolean): Observable<Log>;\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n        if (logId === null || logId === undefined) {\n            throw new Error('Required parameter logId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (timestamp !== undefined && timestamp !== null) {\n            queryParameters = queryParameters.set('timestamp', <any>timestamp);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Log>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/${encodeURIComponent(String(logId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application logs\n     * Get the application logs.  User must have the APPLICATION_LOG[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param from Lower bound of timestamp for filtering.\n     * @param to Upper bound of timestamp for filtering. Must be greater than *from* query param.\n     * @param query Query used for filtering.\n     * @param field Field used for filtering. **required** when type is **GROUP_BY**.\n     * @param order Order used to sort the result list.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean): Observable<LogsResponse>;\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LogsResponse>>;\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LogsResponse>>;\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogs.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<LogsResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { Application } from '../model/application';\nimport { ApplicationInput } from '../model/applicationInput';\nimport { ApplicationsResponse } from '../model/applicationsResponse';\nimport { DateHistoAnalytics, GroupByAnalytics, CountAnalytics } from '../model/models';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { GenericNotificationConfig } from '../model/genericNotificationConfig';\nimport { Log } from '../model/log';\nimport { LogsResponse } from '../model/logsResponse';\nimport { Member } from '../model/member';\nimport { MemberInput } from '../model/memberInput';\nimport { MembersResponse } from '../model/membersResponse';\nimport { NotificationConfigsResponse } from '../model/notificationConfigsResponse';\nimport { PortalNotificationConfig } from '../model/portalNotificationConfig';\nimport { TransferOwnershipInput } from '../model/transferOwnershipInput';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ApplicationsService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Create an application\n     * Create an application.  User must have MANAGEMENT_APPLICATION[CREATE] permission. \n     * @param ApplicationInput Use to create an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApplication(ApplicationInput?: ApplicationInput, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public createApplication(ApplicationInput?: ApplicationInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public createApplication(ApplicationInput?: ApplicationInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public createApplication(ApplicationInput?: ApplicationInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Application>(`${this.configuration.basePath}/applications`,\n            ApplicationInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create an application member\n     * Create an application member.  User must have the APPLICATION_MEMBER[CREATE] permission. \n     * @param applicationId Id of an application.\n     * @param MemberInput Use to create a member.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApplicationMember(applicationId: string, MemberInput?: MemberInput, observe?: 'body', reportProgress?: boolean): Observable<Member>;\n    public createApplicationMember(applicationId: string, MemberInput?: MemberInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Member>>;\n    public createApplicationMember(applicationId: string, MemberInput?: MemberInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Member>>;\n    public createApplicationMember(applicationId: string, MemberInput?: MemberInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling createApplicationMember.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Member>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members`,\n            MemberInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create notification settings.\n     * Create notification settings.  User must have APPLICATION_NOTIFICATION[READ] permission to create a **portal** notification.  User must have APPLICATION_NOTIFICATION[CREATE] permission to create a **generic** notification. \n     * @param applicationId Id of an application.\n     * @param GenericNotificationConfig Use to create an notification\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createApplicationNotification(applicationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe?: 'body', reportProgress?: boolean): Observable<PortalNotificationConfig | GenericNotificationConfig>;\n    public createApplicationNotification(applicationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PortalNotificationConfig | GenericNotificationConfig>>;\n    public createApplicationNotification(applicationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PortalNotificationConfig | GenericNotificationConfig>>;\n    public createApplicationNotification(applicationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling createApplicationNotification.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<PortalNotificationConfig | GenericNotificationConfig>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications`,\n            GenericNotificationConfig,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete an application\n     * Delete an application.  User must have the APPLICATION_DEFINITION[DELETE] permission. \n     * @param applicationId Id of an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApplicationByApplicationId(applicationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteApplicationByApplicationId(applicationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteApplicationByApplicationId(applicationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteApplicationByApplicationId(applicationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove an application member\n     * Remove an application member.  User must have the APPLICATION_MEMBER[DELETE] permission. \n     * @param applicationId Id of an application.\n     * @param memberId Id of a member.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApplicationMember(applicationId: string, memberId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteApplicationMember(applicationId: string, memberId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteApplicationMember(applicationId: string, memberId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteApplicationMember(applicationId: string, memberId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationMember.');\n        }\n        if (memberId === null || memberId === undefined) {\n            throw new Error('Required parameter memberId was null or undefined when calling deleteApplicationMember.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/${encodeURIComponent(String(memberId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a notification\n     * Delete a notification.  User must have APPLICATION_NOTIFICATION[DELETE] permission to delete a **generic** notification. \n     * @param applicationId Id of an application.\n     * @param notificationId Id of a notification.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteApplicationNotificationByNotificationId(applicationId: string, notificationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteApplicationNotificationByNotificationId(applicationId: string, notificationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteApplicationNotificationByNotificationId(applicationId: string, notificationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteApplicationNotificationByNotificationId(applicationId: string, notificationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplicationNotificationByNotificationId.');\n        }\n        if (notificationId === null || notificationId === undefined) {\n            throw new Error('Required parameter notificationId was null or undefined when calling deleteApplicationNotificationByNotificationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications/${encodeURIComponent(String(notificationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Export application logs as CSV\n     * Export application logs as CSV.  User must have the APPLICATION_LOG[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param from Lower bound of timestamp for filtering.\n     * @param to Upper bound of timestamp for filtering. Must be greater than *from* query param.\n     * @param query Query used for filtering.\n     * @param field Field used for filtering. **required** when type is **GROUP_BY**.\n     * @param order Order used to sort the result list.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean): Observable<string>;\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<string>>;\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<string>>;\n    public exportApplicationLogsByApplicationId(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationLogsByApplicationId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'text/plain',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<string>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/_export`,\n            null,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application analytics\n     * Get the application analytics.  User must have the APPLICATION_ANALYTICS[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param from Lower bound of timestamp for filtering.\n     * @param to Upper bound of timestamp for filtering. Must be greater than *from* query param.\n     * @param interval Interval for time search. Must be &gt;&#x3D; 1 000 and &lt;&#x3D; 1 000 000 000.\n     * @param query Query used for filtering.\n     * @param field Field used for filtering. **required** when type is **GROUP_BY**.\n     * @param type Type of analytics that is expected :   - GROUP_BY :       Used to group total hits by a specific field (Application, Status, Path, ...).\\\\       Query params :       - from       - to       - interval       - query       - field       - order       - ranges   - DATE_HISTO :        Used to retrieve total hits per range of time, on a specific time interval.\\\\       Query params :       - from       - to       - interval       - query       - aggs   - COUNT :        Used to retrieve total hits, on a specific time interval.\\\\       Query params :       - from       - to       - interval       - query \n     * @param range Used with GROUP_BY type only.  A semicolon separated list of \\&quot;from:to\\&quot; elements. **_/!\\\\\\\\ Different from *from* and *to* query params** \n     * @param aggs Used with DATE_HISTO type only.  A semicolon separated list of \\&quot;type:field\\&quot; elements. **_/!\\\\\\\\ Different from *type* and *field* query params**\\\\ Type can be **FIELD**, **AVG**, **MIN**, **MAX** \n     * @param order Used with GROUP_BY type only.   A colon separated list of \\&quot;type:field\\&quot; elements. **_/!\\\\\\\\ Different from *type* and *field* query params**\\\\ By default, sort is ASC. If *type* starts with \\&#39;-\\&#39;, the order sort is DESC.\\\\ Currently, only **AVG** is supported. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe?: 'body', reportProgress?: boolean): Observable<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>;\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>>;\n    public getApplicationAnalytics(applicationId: string, page?: number, size?: number, from?: number, to?: number, interval?: number, query?: string, field?: string, type?: 'GROUP_BY' | 'DATE_HISTO' | 'COUNT', range?: string, aggs?: string, order?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationAnalytics.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (interval !== undefined && interval !== null) {\n            queryParameters = queryParameters.set('interval', <any>interval);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (type !== undefined && type !== null) {\n            queryParameters = queryParameters.set('type', <any>type);\n        }\n        if (range !== undefined && range !== null) {\n            queryParameters = queryParameters.set('range', <any>range);\n        }\n        if (aggs !== undefined && aggs !== null) {\n            queryParameters = queryParameters.set('aggs', <any>aggs);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<DateHistoAnalytics | GroupByAnalytics | CountAnalytics>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/analytics`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an application.\n     * Get an application.  User must have the APPLICATION_DEFINITION[READ] permission. \n     * @param applicationId Id of an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationByApplicationId(applicationId: string, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public getApplicationByApplicationId(applicationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public getApplicationByApplicationId(applicationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public getApplicationByApplicationId(applicationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Application>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a specific log of an application\n     * Get a specific log of an application.  User must have the APPLICATION_LOG[READ] permission. \n     * @param applicationId Id of an application.\n     * @param logId Id of a log.\n     * @param timestamp Used to select the right index\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe?: 'body', reportProgress?: boolean): Observable<Log>;\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Log>>;\n    public getApplicationLogByApplicationIdAndLogId(applicationId: string, logId: string, timestamp?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n        if (logId === null || logId === undefined) {\n            throw new Error('Required parameter logId was null or undefined when calling getApplicationLogByApplicationIdAndLogId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (timestamp !== undefined && timestamp !== null) {\n            queryParameters = queryParameters.set('timestamp', <any>timestamp);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Log>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs/${encodeURIComponent(String(logId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Application logs\n     * Get the application logs.  User must have the APPLICATION_LOG[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param from Lower bound of timestamp for filtering.\n     * @param to Upper bound of timestamp for filtering. Must be greater than *from* query param.\n     * @param query Query used for filtering.\n     * @param field Field used for filtering. **required** when type is **GROUP_BY**.\n     * @param order Order used to sort the result list.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'body', reportProgress?: boolean): Observable<LogsResponse>;\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LogsResponse>>;\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LogsResponse>>;\n    public getApplicationLogs(applicationId: string, page?: number, size?: number, from?: number, to?: number, query?: string, field?: string, order?: 'ASC' | 'DESC', observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLogs.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (from !== undefined && from !== null) {\n            queryParameters = queryParameters.set('from', <any>from);\n        }\n        if (to !== undefined && to !== null) {\n            queryParameters = queryParameters.set('to', <any>to);\n        }\n        if (query !== undefined && query !== null) {\n            queryParameters = queryParameters.set('query', <any>query);\n        }\n        if (field !== undefined && field !== null) {\n            queryParameters = queryParameters.set('field', <any>field);\n        }\n        if (order !== undefined && order !== null) {\n            queryParameters = queryParameters.set('order', <any>order);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<LogsResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/logs`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an application member\n     * Get an application member.  User must have the APPLICATION_MEMBER[READ] permission. \n     * @param applicationId Id of an application.\n     * @param memberId Id of a member.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, observe?: 'body', reportProgress?: boolean): Observable<Member>;\n    public getApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Member>>;\n    public getApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Member>>;\n    public getApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationMemberByApplicationIdAndMemberId.');\n        }\n        if (memberId === null || memberId === undefined) {\n            throw new Error('Required parameter memberId was null or undefined when calling getApplicationMemberByApplicationIdAndMemberId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Member>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/${encodeURIComponent(String(memberId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the application\\&#39;s picture\n     * Get the application\\&#39;s picture.  User must have APPLICATION_DEFINITION[READ] permission. \n     * @param applicationId Id of an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplicationPictureByApplicationId(applicationId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getApplicationPictureByApplicationId(applicationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getApplicationPictureByApplicationId(applicationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getApplicationPictureByApplicationId(applicationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationPictureByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/picture`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List all the applications accessible to authenticated user.\n     * List all the applications accessible to authenticated user.  User must have MANAGEMENT_APPLICATION[READ] and PORTAL_APPLICATION[READ] permission. \n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getApplications(page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<ApplicationsResponse>;\n    public getApplications(page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ApplicationsResponse>>;\n    public getApplications(page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ApplicationsResponse>>;\n    public getApplications(page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ApplicationsResponse>(`${this.configuration.basePath}/applications`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List application members\n     * List application members.  User must have the APPLICATION_MEMBER[READ] permission. \n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getMembersByApplicationId(applicationId: string, page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<MembersResponse>;\n    public getMembersByApplicationId(applicationId: string, page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MembersResponse>>;\n    public getMembersByApplicationId(applicationId: string, page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MembersResponse>>;\n    public getMembersByApplicationId(applicationId: string, page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getMembersByApplicationId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<MembersResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get application notifications settings\n     * Get application notifications settings.  User must **at least** have APPLICATION_NOTIFICATION[READ] permission to get **portal** notification settings.  User must **also** have APPLICATION_NOTIFICATION[CREATE | UPDATE | DELETE] permission to get **generic** notification settings. \n     * @param applicationId Id of an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getNotificationsByApplicationId(applicationId: string, observe?: 'body', reportProgress?: boolean): Observable<NotificationConfigsResponse>;\n    public getNotificationsByApplicationId(applicationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NotificationConfigsResponse>>;\n    public getNotificationsByApplicationId(applicationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NotificationConfigsResponse>>;\n    public getNotificationsByApplicationId(applicationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling getNotificationsByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<NotificationConfigsResponse>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Renew the client secret for an OAuth2 application\n     * Renew the client secret for an OAuth2 application.  User must have the APPLICATION_DEFINITION[UPDATE] permission. \n     * @param applicationId Id of an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public renewApplicationSecret(applicationId: string, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public renewApplicationSecret(applicationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public renewApplicationSecret(applicationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public renewApplicationSecret(applicationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling renewApplicationSecret.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<Application>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/_renew_secret`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Transfer the ownership of the application\n     * Transfer the ownership of the application.  User must have the APPLICATION_MEMBER[UPDATE] permission. \n     * @param applicationId Id of an application.\n     * @param TransferOwnershipInput Use to transfer ownership of an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public transferMemberOwnership(applicationId: string, TransferOwnershipInput?: TransferOwnershipInput, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public transferMemberOwnership(applicationId: string, TransferOwnershipInput?: TransferOwnershipInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public transferMemberOwnership(applicationId: string, TransferOwnershipInput?: TransferOwnershipInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public transferMemberOwnership(applicationId: string, TransferOwnershipInput?: TransferOwnershipInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling transferMemberOwnership.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/_transfer_ownership`,\n            TransferOwnershipInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an application.\n     * Update an application.  User must have APPLICATION_DEFINITION[UPDATE] permission. \n     * @param applicationId Id of an application.\n     * @param Application Use to update an application.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateApplicationByApplicationId(applicationId: string, Application?: Application, observe?: 'body', reportProgress?: boolean): Observable<Application>;\n    public updateApplicationByApplicationId(applicationId: string, Application?: Application, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Application>>;\n    public updateApplicationByApplicationId(applicationId: string, Application?: Application, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Application>>;\n    public updateApplicationByApplicationId(applicationId: string, Application?: Application, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updateApplicationByApplicationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<Application>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}`,\n            Application,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an application member.\n     * Update an application member.  User must have the APPLICATION_MEMBER[UPDATE] permission. \n     * @param applicationId Id of an application.\n     * @param memberId Id of a member.\n     * @param MemberInput Use to update a member.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, MemberInput?: MemberInput, observe?: 'body', reportProgress?: boolean): Observable<Member>;\n    public updateApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, MemberInput?: MemberInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Member>>;\n    public updateApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, MemberInput?: MemberInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Member>>;\n    public updateApplicationMemberByApplicationIdAndMemberId(applicationId: string, memberId: string, MemberInput?: MemberInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updateApplicationMemberByApplicationIdAndMemberId.');\n        }\n        if (memberId === null || memberId === undefined) {\n            throw new Error('Required parameter memberId was null or undefined when calling updateApplicationMemberByApplicationIdAndMemberId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<Member>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/members/${encodeURIComponent(String(memberId))}`,\n            MemberInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a generic notification for an application.\n     * Update a generic notification for an application.  User must have APPLICATION_NOTIFICATION[UPDATE] permission to update a **generic** notification. \n     * @param applicationId Id of an application.\n     * @param notificationId Id of a notification.\n     * @param GenericNotificationConfig Use to update a generic notification.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateGenericApplicationNotification(applicationId: string, notificationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe?: 'body', reportProgress?: boolean): Observable<GenericNotificationConfig>;\n    public updateGenericApplicationNotification(applicationId: string, notificationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GenericNotificationConfig>>;\n    public updateGenericApplicationNotification(applicationId: string, notificationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GenericNotificationConfig>>;\n    public updateGenericApplicationNotification(applicationId: string, notificationId: string, GenericNotificationConfig?: GenericNotificationConfig, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updateGenericApplicationNotification.');\n        }\n        if (notificationId === null || notificationId === undefined) {\n            throw new Error('Required parameter notificationId was null or undefined when calling updateGenericApplicationNotification.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<GenericNotificationConfig>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications/${encodeURIComponent(String(notificationId))}`,\n            GenericNotificationConfig,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update a portal notification for an application.\n     * Update a portal notification for an application.  User must have APPLICATION_NOTIFICATION[READ] permission to update a **portal** notification. \n     * @param applicationId Id of an application.\n     * @param PortalNotificationConfig Use to update a portal notification config.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePortalApplicationNotification(applicationId: string, PortalNotificationConfig?: PortalNotificationConfig, observe?: 'body', reportProgress?: boolean): Observable<PortalNotificationConfig>;\n    public updatePortalApplicationNotification(applicationId: string, PortalNotificationConfig?: PortalNotificationConfig, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PortalNotificationConfig>>;\n    public updatePortalApplicationNotification(applicationId: string, PortalNotificationConfig?: PortalNotificationConfig, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PortalNotificationConfig>>;\n    public updatePortalApplicationNotification(applicationId: string, PortalNotificationConfig?: PortalNotificationConfig, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (applicationId === null || applicationId === undefined) {\n            throw new Error('Required parameter applicationId was null or undefined when calling updatePortalApplicationNotification.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<PortalNotificationConfig>(`${this.configuration.basePath}/applications/${encodeURIComponent(String(applicationId))}/notifications`,\n            PortalNotificationConfig,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { PayloadInput } from '../model/payloadInput';\nimport { Token } from '../model/token';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthenticationService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Used to get a gravitee token from an Authorization code (PayloadInput.code). Portal API authenticates the user with the specified IDP ({identity} path param). \n     * @param identity \n     * @param PayloadInput OAuth2 payload for authentication.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public exchangeAuthorizationCode(identity: string, PayloadInput?: PayloadInput, observe?: 'body', reportProgress?: boolean): Observable<Token>;\n    public exchangeAuthorizationCode(identity: string, PayloadInput?: PayloadInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\n    public exchangeAuthorizationCode(identity: string, PayloadInput?: PayloadInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\n    public exchangeAuthorizationCode(identity: string, PayloadInput?: PayloadInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (identity === null || identity === undefined) {\n            throw new Error('Required parameter identity was null or undefined when calling exchangeAuthorizationCode.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Token>(`${this.configuration.basePath}/auth/oauth2/${encodeURIComponent(String(identity))}`,\n            PayloadInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Used to get a Gravitee token. This token is mandatory for all the secured resources of the Portal API. \n     * @param Authorization Basic authentication.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public login(Authorization: string, observe?: 'body', reportProgress?: boolean): Observable<Token>;\n    public login(Authorization: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\n    public login(Authorization: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\n    public login(Authorization: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (Authorization === null || Authorization === undefined) {\n            throw new Error('Required parameter Authorization was null or undefined when calling login.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (Authorization !== undefined && Authorization !== null) {\n            headers = headers.set('Authorization', String(Authorization));\n        }\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<Token>(`${this.configuration.basePath}/auth/login`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * User need to be authenticated to logout. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public logout(observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public logout(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public logout(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public logout(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/auth/logout`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Used to get a gravitee token from a IdentityProvider token. Portal API authenticates the user with the specified IDP ({identity} path param). \n     * @param identity \n     * @param token \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public tokenExchange(identity: string, token: string, observe?: 'body', reportProgress?: boolean): Observable<Token>;\n    public tokenExchange(identity: string, token: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\n    public tokenExchange(identity: string, token: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\n    public tokenExchange(identity: string, token: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (identity === null || identity === undefined) {\n            throw new Error('Required parameter identity was null or undefined when calling tokenExchange.');\n        }\n        if (token === null || token === undefined) {\n            throw new Error('Required parameter token was null or undefined when calling tokenExchange.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (token !== undefined && token !== null) {\n            queryParameters = queryParameters.set('token', <any>token);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<Token>(`${this.configuration.basePath}/auth/oauth2/${encodeURIComponent(String(identity))}/_exchange`,\n            null,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Page } from '../model/page';\nimport { PagesResponse } from '../model/pagesResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DocumentationService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Get an API page\n     * Get an API page.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param pageId Id of a documentation page.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe?: 'body', reportProgress?: boolean): Observable<Page>;\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;\n    public getPageByApiIdAndPageId(apiId: string, pageId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n        if (pageId === null || pageId === undefined) {\n            throw new Error('Required parameter pageId was null or undefined when calling getPageByApiIdAndPageId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Page>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages/${encodeURIComponent(String(pageId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a portal page\n     * Get a specific portal documentation page. \n     * @param pageId Id of a documentation page.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPageByPageId(pageId: string, observe?: 'body', reportProgress?: boolean): Observable<Page>;\n    public getPageByPageId(pageId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Page>>;\n    public getPageByPageId(pageId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Page>>;\n    public getPageByPageId(pageId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (pageId === null || pageId === undefined) {\n            throw new Error('Required parameter pageId was null or undefined when calling getPageByPageId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Page>(`${this.configuration.basePath}/pages/${encodeURIComponent(String(pageId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List portal pages\n     * List all portal documentation pages \n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param homepage If true, only the documentation homepage of the portal is returned.\n     * @param parent The name of the parent documentation page. If not null, only this page and its children are returned.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPages(page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;\n    public getPages(page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;\n    public getPages(page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;\n    public getPages(page?: number, size?: number, homepage?: boolean, parent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (homepage !== undefined && homepage !== null) {\n            queryParameters = queryParameters.set('homepage', <any>homepage);\n        }\n        if (parent !== undefined && parent !== null) {\n            queryParameters = queryParameters.set('parent', <any>parent);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/pages`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List API pages\n     * List all documentation pages of an API.  This API has to be accessible by the current user, otherwise a 404 will be returned. \n     * @param apiId Id of an API.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param homepage If true, only the documentation homepage of the portal is returned.\n     * @param parent The name of the parent documentation page. If not null, only this page and its children are returned.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'body', reportProgress?: boolean): Observable<PagesResponse>;\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PagesResponse>>;\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PagesResponse>>;\n    public getPagesByApiId(apiId: string, page?: number, size?: number, homepage?: boolean, parent?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (apiId === null || apiId === undefined) {\n            throw new Error('Required parameter apiId was null or undefined when calling getPagesByApiId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n        if (homepage !== undefined && homepage !== null) {\n            queryParameters = queryParameters.set('homepage', <any>homepage);\n        }\n        if (parent !== undefined && parent !== null) {\n            queryParameters = queryParameters.set('parent', <any>parent);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PagesResponse>(`${this.configuration.basePath}/apis/${encodeURIComponent(String(apiId))}/pages`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ConfigurationIdentitiesResponse } from '../model/configurationIdentitiesResponse';\nimport { ConfigurationResponse } from '../model/configurationResponse';\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Info } from '../model/info';\nimport { TicketInput } from '../model/ticketInput';\nimport { View } from '../model/view';\nimport { ViewsResponse } from '../model/viewsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PortalService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Create a ticket.\n     * Create a ticket. This ticket can aim :   * a specific application   * a specific API   * the gravitee portal  User must be authenticated to use this service. \n     * @param TicketInput a new ticket to create\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createTicket(TicketInput?: TicketInput, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public createTicket(TicketInput?: TicketInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public createTicket(TicketInput?: TicketInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public createTicket(TicketInput?: TicketInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/tickets`,\n            TicketInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get picture of a View\n     * Get the picture of a view. \n     * @param viewId Id of a View.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPictureByViewId(viewId: string, observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getPictureByViewId(viewId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getPictureByViewId(viewId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getPictureByViewId(viewId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (viewId === null || viewId === undefined) {\n            throw new Error('Required parameter viewId was null or undefined when calling getPictureByViewId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/views/${encodeURIComponent(String(viewId))}/picture`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get portal configuration.\n     * Get all the portal configuration from the platform settings. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPortalConfiguration(observe?: 'body', reportProgress?: boolean): Observable<ConfigurationResponse>;\n    public getPortalConfiguration(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationResponse>>;\n    public getPortalConfiguration(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationResponse>>;\n    public getPortalConfiguration(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ConfigurationResponse>(`${this.configuration.basePath}/configuration`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the identity provider list.\n     * Get all the identity providers that can used in the portal. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPortalIdentityProviders(observe?: 'body', reportProgress?: boolean): Observable<ConfigurationIdentitiesResponse>;\n    public getPortalIdentityProviders(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConfigurationIdentitiesResponse>>;\n    public getPortalIdentityProviders(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConfigurationIdentitiesResponse>>;\n    public getPortalIdentityProviders(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ConfigurationIdentitiesResponse>(`${this.configuration.basePath}/configuration/identities`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get portal information.\n     * Get some information about the portal (version, ...). \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPortalInformation(observe?: 'body', reportProgress?: boolean): Observable<Info>;\n    public getPortalInformation(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Info>>;\n    public getPortalInformation(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Info>>;\n    public getPortalInformation(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Info>(`${this.configuration.basePath}/info`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a View\n     * Get a specific view. \n     * @param viewId Id of a View.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getViewByViewId(viewId: string, observe?: 'body', reportProgress?: boolean): Observable<View>;\n    public getViewByViewId(viewId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<View>>;\n    public getViewByViewId(viewId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<View>>;\n    public getViewByViewId(viewId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (viewId === null || viewId === undefined) {\n            throw new Error('Required parameter viewId was null or undefined when calling getViewByViewId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<View>(`${this.configuration.basePath}/views/${encodeURIComponent(String(viewId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a View list\n     * Get all views of the platform. \n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getViews(page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<ViewsResponse>;\n    public getViews(page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ViewsResponse>>;\n    public getViews(page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ViewsResponse>>;\n    public getViews(page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<ViewsResponse>(`${this.configuration.basePath}/views`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { Key } from '../model/key';\nimport { Subscription } from '../model/subscription';\nimport { SubscriptionInput } from '../model/subscriptionInput';\nimport { SubscriptionsResponse } from '../model/subscriptionsResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SubscriptionService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Close a subscription\n     * Close a subscription.  User must have APPLICATION_SUBSCRIPTION[DELETE] permission. \n     * @param subscriptionId Id of a subscription.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public closeSubscription(subscriptionId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public closeSubscription(subscriptionId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public closeSubscription(subscriptionId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public closeSubscription(subscriptionId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling closeSubscription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}/_close`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create a subscription.\n     * Create a new subscription.  User must have APPLICATION_SUBSCRIPTION[CREATE] permission. \n     * @param SubscriptionInput Use to create a subscription.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createSubscription(SubscriptionInput?: SubscriptionInput, observe?: 'body', reportProgress?: boolean): Observable<Subscription>;\n    public createSubscription(SubscriptionInput?: SubscriptionInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Subscription>>;\n    public createSubscription(SubscriptionInput?: SubscriptionInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Subscription>>;\n    public createSubscription(SubscriptionInput?: SubscriptionInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Subscription>(`${this.configuration.basePath}/subscriptions`,\n            SubscriptionInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a subscription.\n     * Get a subscription.  User must have API_SUBSCRIPTION[CREATE] or APPLICATION_SUBSCRIPTION[CREATE] permission. \n     * @param subscriptionId Id of a subscription.\n     * @param include Comma-separated list of related objects to include in the response.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSubscriptionBuySubscriptionId(subscriptionId: string, include?: Array<'keys'>, observe?: 'body', reportProgress?: boolean): Observable<Subscription>;\n    public getSubscriptionBuySubscriptionId(subscriptionId: string, include?: Array<'keys'>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Subscription>>;\n    public getSubscriptionBuySubscriptionId(subscriptionId: string, include?: Array<'keys'>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Subscription>>;\n    public getSubscriptionBuySubscriptionId(subscriptionId: string, include?: Array<'keys'>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling getSubscriptionBuySubscriptionId.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (include) {\n            include.forEach((element) => {\n                queryParameters = queryParameters.append('include', <any>element);\n            })\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<Subscription>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List all subscriptions, filtered by api and/or by application. At least an api or an application must be provided.  User must have the APPLICATION_SUBSCRIPTION[READ] permission to list subscription with application query param.\\\\ User must have the API_SUBSCRIPTION[READ] permission to list subscription with api query param. \n     * @param apiId Id of an api.\n     * @param applicationId Id of an application.\n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSubscriptions(apiId?: string, applicationId?: string, page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<SubscriptionsResponse>;\n    public getSubscriptions(apiId?: string, applicationId?: string, page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubscriptionsResponse>>;\n    public getSubscriptions(apiId?: string, applicationId?: string, page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubscriptionsResponse>>;\n    public getSubscriptions(apiId?: string, applicationId?: string, page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (apiId !== undefined && apiId !== null) {\n            queryParameters = queryParameters.set('apiId', <any>apiId);\n        }\n        if (applicationId !== undefined && applicationId !== null) {\n            queryParameters = queryParameters.set('applicationId', <any>applicationId);\n        }\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<SubscriptionsResponse>(`${this.configuration.basePath}/subscriptions`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Renew a key subscription.\n     * Renew a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. \n     * @param subscriptionId Id of a subscription.\n     * @param request_body Use to renew keys of a subscription.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public renewKeySubscription(subscriptionId: string, request_body?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<Key>;\n    public renewKeySubscription(subscriptionId: string, request_body?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Key>>;\n    public renewKeySubscription(subscriptionId: string, request_body?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Key>>;\n    public renewKeySubscription(subscriptionId: string, request_body?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling renewKeySubscription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<Key>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}/keys/_renew`,\n            request_body,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Revoke a key subscription.\n     * Revoke a key subscription.  User must have API_SUBSCRIPTION[UPDATE] or APPLICATION_SUBSCRIPTION[UPDATE] permission. \n     * @param subscriptionId Id of a subscription.\n     * @param keyId \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public revokeKeySubscription(subscriptionId: string, keyId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public revokeKeySubscription(subscriptionId: string, keyId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public revokeKeySubscription(subscriptionId: string, keyId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public revokeKeySubscription(subscriptionId: string, keyId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (subscriptionId === null || subscriptionId === undefined) {\n            throw new Error('Required parameter subscriptionId was null or undefined when calling revokeKeySubscription.');\n        }\n        if (keyId === null || keyId === undefined) {\n            throw new Error('Required parameter keyId was null or undefined when calling revokeKeySubscription.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/subscriptions/${encodeURIComponent(String(subscriptionId))}/keys/${encodeURIComponent(String(keyId))}/_revoke`,\n            null,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { PortalNotificationsResponse } from '../model/portalNotificationsResponse';\nimport { User } from '../model/user';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Delete all notifications of the current user\n     * Delete all notifications of the current user. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteAllCurrentUserNotifications(observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteAllCurrentUserNotifications(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteAllCurrentUserNotifications(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteAllCurrentUserNotifications(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/user/notifications`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a specific notification of the current user\n     * Delete a specific notification of the current user. \n     * @param notificationId Id of a notification.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteCurrentUserNotificationByNotificationId(notificationId: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\n    public deleteCurrentUserNotificationByNotificationId(notificationId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\n    public deleteCurrentUserNotificationByNotificationId(notificationId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\n    public deleteCurrentUserNotificationByNotificationId(notificationId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n        if (notificationId === null || notificationId === undefined) {\n            throw new Error('Required parameter notificationId was null or undefined when calling deleteCurrentUserNotificationByNotificationId.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/user/notifications/${encodeURIComponent(String(notificationId))}`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the authenticated user\n     * Get information about the authenticated user. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUser(observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public getCurrentUser(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public getCurrentUser(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public getCurrentUser(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<User>(`${this.configuration.basePath}/user`,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve user\\&#39;s avatar\n     * Retrieve user\\&#39;s avatar. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUserAvatar(observe?: 'body', reportProgress?: boolean): Observable<Blob>;\n    public getCurrentUserAvatar(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Blob>>;\n    public getCurrentUserAvatar(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Blob>>;\n    public getCurrentUserAvatar(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'image/_*',\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get(`${this.configuration.basePath}/user/avatar`,\n            {\n                responseType: \"blob\",\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Retrieve user\\&#39;s notifications\n     * Retrieve current user\\&#39;s notifications. \n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCurrentUserNotifications(page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<PortalNotificationsResponse>;\n    public getCurrentUserNotifications(page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PortalNotificationsResponse>>;\n    public getCurrentUserNotifications(page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PortalNotificationsResponse>>;\n    public getCurrentUserNotifications(page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<PortalNotificationsResponse>(`${this.configuration.basePath}/user/notifications`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Modify current user information.\n     * Modify current user information.  Only the current user can modify his/her information. \n     * @param User Use to update a user.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCurrentUser(User?: User, observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public updateCurrentUser(User?: User, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public updateCurrentUser(User?: User, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public updateCurrentUser(User?: User, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.put<User>(`${this.configuration.basePath}/user`,\n            User,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ErrorResponse } from '../model/errorResponse';\nimport { FinalizeRegistrationInput } from '../model/finalizeRegistrationInput';\nimport { RegisterUserInput } from '../model/registerUserInput';\nimport { User } from '../model/user';\nimport { UsersResponse } from '../model/usersResponse';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UsersService {\n\n    protected basePath = 'http://demo.gravitee.io/portal/DEFAULT';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    /**\n     * Finalize user registration.\n     * Create a new user for the portal.  User registration must be enabled. \n     * @param FinalizeRegistrationInput Used to finalize a user registration.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public finalizeUserRegistration(FinalizeRegistrationInput?: FinalizeRegistrationInput, observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public finalizeUserRegistration(FinalizeRegistrationInput?: FinalizeRegistrationInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public finalizeUserRegistration(FinalizeRegistrationInput?: FinalizeRegistrationInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public finalizeUserRegistration(FinalizeRegistrationInput?: FinalizeRegistrationInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<User>(`${this.configuration.basePath}/users/registration/_finalize`,\n            FinalizeRegistrationInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * List platform users.\n     * List platform users.  User must have the MANAGEMENT_USERS[READ] permission. \n     * @param page The page number for pagination.\n     * @param size The number of items per page for pagination.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUsers(page?: number, size?: number, observe?: 'body', reportProgress?: boolean): Observable<UsersResponse>;\n    public getUsers(page?: number, size?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UsersResponse>>;\n    public getUsers(page?: number, size?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UsersResponse>>;\n    public getUsers(page?: number, size?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (page !== undefined && page !== null) {\n            queryParameters = queryParameters.set('page', <any>page);\n        }\n        if (size !== undefined && size !== null) {\n            queryParameters = queryParameters.set('size', <any>size);\n        }\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        return this.httpClient.get<UsersResponse>(`${this.configuration.basePath}/users`,\n            {\n                params: queryParameters,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Register a new user.\n     * Register a new user for the portal. As a result, an email is sent with an activation link.  User registration must be enabled.\\\\ A SMTP server must have been configured. \n     * @param RegisterUserInput Used to register a new User.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public registerNewUser(RegisterUserInput?: RegisterUserInput, observe?: 'body', reportProgress?: boolean): Observable<User>;\n    public registerNewUser(RegisterUserInput?: RegisterUserInput, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\n    public registerNewUser(RegisterUserInput?: RegisterUserInput, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\n    public registerNewUser(RegisterUserInput?: RegisterUserInput, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        // authentication (BasicAuth) required\n        if (this.configuration.username || this.configuration.password) {\n            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));\n        }\n        // authentication (CookieAuth) required\n        // to determine the Accept header\n        const httpHeaderAccepts: string[] = [\n            'application/json'\n        ];\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        return this.httpClient.post<User>(`${this.configuration.basePath}/users/registration`,\n            RegisterUserInput,\n            {\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './aPI.service';\nimport { APIService } from './aPI.service';\nexport * from './analytics.service';\nimport { AnalyticsService } from './analytics.service';\nexport * from './applications.service';\nimport { ApplicationsService } from './applications.service';\nexport * from './authentication.service';\nimport { AuthenticationService } from './authentication.service';\nexport * from './documentation.service';\nimport { DocumentationService } from './documentation.service';\nexport * from './portal.service';\nimport { PortalService } from './portal.service';\nexport * from './subscription.service';\nimport { SubscriptionService } from './subscription.service';\nexport * from './user.service';\nimport { UserService } from './user.service';\nexport * from './users.service';\nimport { UsersService } from './users.service';\nexport const APIS = [APIService, AnalyticsService, ApplicationsService, AuthenticationService, DocumentationService, PortalService, SubscriptionService, UserService, UsersService];\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { PageConfiguration } from './pageConfiguration';\nimport { Metadata } from './metadata';\n\n\nexport interface Page { \n    /**\n     * Unique identifier of a page.\n     */\n    id: string;\n    /**\n     * Name of the page.\n     */\n    name: string;\n    /**\n     * Type of documentation.\n     */\n    type: Page.TypeEnum;\n    /**\n     * Order of the documentation page in its folder.\n     */\n    order: number;\n    /**\n     * Parent page. MAY be null.\n     */\n    parent?: string;\n    /**\n     * Last update date and time.\n     */\n    updated_at?: Date;\n    /**\n     * Raw content of the page.\n     */\n    content?: string;\n    /**\n     * Array of key-value about the page.\n     */\n    configuraton?: Array<PageConfiguration>;\n    /**\n     * Array of metadata about the page. This array is filled when the page has been fetched from a distant source (GitHub, GitLab, etc...).\n     */\n    metadata?: Array<Metadata>;\n}\nexport namespace Page {\n    export type TypeEnum = 'SWAGGER' | 'MARKDOWN' | 'FOLDER' | 'ROOT';\n    export const TypeEnum = {\n        SWAGGER: 'SWAGGER' as TypeEnum,\n        MARKDOWN: 'MARKDOWN' as TypeEnum,\n        FOLDER: 'FOLDER' as TypeEnum,\n        ROOT: 'ROOT' as TypeEnum\n    };\n}\n\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { Key } from './key';\n\n\nexport interface Subscription { \n    /**\n     * Unique identifier of a subscription.\n     */\n    id: string;\n    /**\n     * Subscribed API.\n     */\n    api: string;\n    /**\n     * Subscribing application.\n     */\n    application: string;\n    /**\n     * Subscribed plan.\n     */\n    plan: string;\n    /**\n     * Comment of the user when asking for a subscription.\n     */\n    request?: string;\n    /**\n     * Creation date and time of the subscription.\n     */\n    created_at?: Date;\n    /**\n     * Date and time when the subscription request was processed.\n     */\n    processed_at?: Date;\n    /**\n     * Start date and time of the subscription.\n     */\n    start_at?: Date;\n    /**\n     * Expiration date and time of the subscription.\n     */\n    end_at?: Date;\n    /**\n     * Status of the subscription.\n     */\n    status: Subscription.StatusEnum;\n    /**\n     * Only returned with *_/subscriptions/{subscriptionId}*. Need *include* query param to contain \\'keys\\'.  List of APIKeys of the subscription. \n     */\n    keys?: Array<Key>;\n}\nexport namespace Subscription {\n    export type StatusEnum = 'PENDING' | 'ACCEPTED' | 'REJECTED';\n    export const StatusEnum = {\n        PENDING: 'PENDING' as StatusEnum,\n        ACCEPTED: 'ACCEPTED' as StatusEnum,\n        REJECTED: 'REJECTED' as StatusEnum\n    };\n}\n\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface Token { \n    token_type?: Token.TokenTypeEnum;\n    token?: string;\n}\nexport namespace Token {\n    export type TokenTypeEnum = 'BEARER';\n    export const TokenTypeEnum = {\n        BEARER: 'BEARER' as TokenTypeEnum\n    };\n}\n\n\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\n\nimport { APIService } from './api/aPI.service';\nimport { AnalyticsService } from './api/analytics.service';\nimport { ApplicationsService } from './api/applications.service';\nimport { AuthenticationService } from './api/authentication.service';\nimport { DocumentationService } from './api/documentation.service';\nimport { PortalService } from './api/portal.service';\nimport { SubscriptionService } from './api/subscription.service';\nimport { UserService } from './api/user.service';\nimport { UsersService } from './api/users.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: [\n    APIService,\n    AnalyticsService,\n    ApplicationsService,\n    AuthenticationService,\n    DocumentationService,\n    PortalService,\n    SubscriptionService,\n    UserService,\n    UsersService ]\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport type CategoryApiQuery = 'FEATURED' | 'MINE' | 'STARRED' | 'TRENDINGS';\n\nexport const CategoryApiQuery = {\n    FEATURED: 'FEATURED' as CategoryApiQuery,\n    MINE: 'MINE' as CategoryApiQuery,\n    STARRED: 'STARRED' as CategoryApiQuery,\n    TRENDINGS: 'TRENDINGS' as CategoryApiQuery\n};\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport type HttpMethod = 'CONNECT' | 'DELETE' | 'GET' | 'HEAD' | 'OPTIONS' | 'PATCH' | 'POST' | 'PUT' | 'TRACE' | 'OTHER';\n\nexport const HttpMethod = {\n    CONNECT: 'CONNECT' as HttpMethod,\n    DELETE: 'DELETE' as HttpMethod,\n    GET: 'GET' as HttpMethod,\n    HEAD: 'HEAD' as HttpMethod,\n    OPTIONS: 'OPTIONS' as HttpMethod,\n    PATCH: 'PATCH' as HttpMethod,\n    POST: 'POST' as HttpMethod,\n    PUT: 'PUT' as HttpMethod,\n    TRACE: 'TRACE' as HttpMethod,\n    OTHER: 'OTHER' as HttpMethod\n};\n\n","/**\n * Gravitee.io Portal Rest API\n * API dedicated to the devportal part of Gravitee\n *\n * The version of the OpenAPI document: 3.0.0\n * Contact: contact@graviteesource.com\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\n/**\n * type of Identity Provider\n */\nexport type IdentityProviderType = 'GOOGLE' | 'GITHUB' | 'GRAVITEEIO_AM' | 'OIDC';\n\nexport const IdentityProviderType = {\n    GOOGLE: 'GOOGLE' as IdentityProviderType,\n    GITHUB: 'GITHUB' as IdentityProviderType,\n    GRAVITEEIOAM: 'GRAVITEEIO_AM' as IdentityProviderType,\n    OIDC: 'OIDC' as IdentityProviderType\n};\n\n"]}